### 代码加锁，不要让"锁"事成为烦心事
---
1. 加锁前要清楚锁和被保护的对象是不是一个层面的: **lockscope**
2. 加锁要考虑锁的粒度和场景问题: **lockgranularity**
3. 多把锁要小心死锁问题:  **deadlock**


+ 第一,使用synchronized加锁虽然简单,但我们首先要弄清楚共享资源是类还是实例级别
的、会被哪些线程操作, synchronized 关联的锁对象或方法又是什么范围的。

+ 第二,加锁尽可能要考虑粒度和场景,锁保护的代码意味着无法进行多线程操作。对于Web
类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必
要的代码块加锁，降低锁的粒度;而对于要求超高性能的业务,还要细化考虑锁的读写场景，
以及悲观优先还是乐观优先,尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑
使用ReentrantReadWritelock. Stampedlock 等高级的锁工类。

+ 第三,业务逻辑中有多把锁时要考虑死锁问题,通常的规避方案是,避免无限等待和循环等
待。

+ 此外，如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对,是否有遗漏
  释放或重复释放的可能性;并且要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，
  如果别的线线程或进程拿到了相同的锁，可能会导致重复执行。

